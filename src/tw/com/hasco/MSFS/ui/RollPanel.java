/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package tw.com.hasco.MSFS.ui;

import java.awt.BasicStroke;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.JFrame;
import javax.swing.JPanel;
import tw.com.hasco.MSFS.FS.FSBasic;
import tw.com.hasco.MSFS.locale.LocaleManager;

/**
 *
 * @author DELL
 */
public class RollPanel extends javax.swing.JPanel {

    double bank;
    int aileronDeflection;
    int aileronControl;
    BufferedImage planeFront;
    BufferedImage pic;

    /**
     * Creates new form PlotFrontPanel
     */
    public RollPanel() {
        initComponents();
        try {
            bank = 30;
            aileronControl = 0;
            this.aileronDeflection = 5;
            ClassLoader classLoader = getClass().getClassLoader();
            planeFront = ImageIO.read(classLoader.getResourceAsStream("draw/front.png"));
            BufferedImage before = ImageIO.read(classLoader.getResourceAsStream("draw/pic2.png"));
            int w = before.getWidth();
            int h = before.getHeight();
            pic = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);
            AffineTransform at = new AffineTransform();
            at.scale(0.583, 0.583);
            AffineTransformOp scaleOp
                    = new AffineTransformOp(at, AffineTransformOp.TYPE_BILINEAR);
            pic = scaleOp.filter(before, pic);
            // pic = ImageIO.read(classLoader.getResourceAsStream("draw/pic2.png"));
        } catch (IOException ex) {
            Logger.getLogger(RollPanel.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 350, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
 @Override
    public void paintComponent(Graphics g) {

        super.paintComponent(g);
        LocaleManager l = LocaleManager.getInstance("Taiwan");
        Graphics2D g2d = (Graphics2D) g;
        g2d.setRenderingHint(
                RenderingHints.KEY_ANTIALIASING,
                RenderingHints.VALUE_ANTIALIAS_ON
        );
        double width = getWidth();
        double height = getHeight();
        double planeWidth = planeFront.getWidth();
        double planeHeight = planeFront.getHeight();
        double x, y, x1, y1, x2, y2, x3, y3, x4, y4;
        //Font currentFont = g.getFont();
        //Font newFont = currentFont.deriveFont(currentFont.getSize() * 1.4F);
        //g.setFont(newFont);
        // title string
        x = 0.05 * width;
        y = 0.05 * height;
        g2d.drawString(l.getString("rollPanelStr")+" Roll Control & Attitude Dynamic Graphic", (int) x, (int) y);
        // symbol table
        x = 0.05 * width;
        y = 0.85 * height;
        g2d.drawString("\u03D5:" + l.getString("bank") + ":" + (int) bank, (int) x, (int) y);
        g2d.drawString("\u03B4A:" + l.getString("aileronDeflection") + ":" + this.aileronDeflection, (int) x, (int) y + g.getFont().getSize() + 10);
        // draw bank            
        double bankInRad = Math.toRadians(bank);
        AffineTransform at = new AffineTransform();
        // 4. translate it to the center of the component
        at.translate(width / 2, height / 2);

        // 3. do the actual rotation, for ccw is positive
        at.rotate(1.0 * bankInRad);

        // 2. just a scale because this image is big
        // overtime 1.8/2.6
        // at.scale(0.583, 0.583);
        at.scale(0.404, 0.404);
        // 1. translate the object so that you rotate it around the 
        //    center (easier :))
        at.translate(-planeWidth / 2, -planeHeight * 4 / 7);

        // draw the image
        g2d.drawImage(planeFront, at, null);
        // draw pitch
        g.setColor(java.awt.Color.green);
        g2d.drawLine((int) (0.45 * width), (int) (height / 2), (int) (0.9 * width), (int) (height / 2));
        g2d.drawLine((int) (0.5 * width), (int) (0.55 * height), (int) (0.5 * width), (int) (0.2 * height));
        x1 = 0.5 * width + 0.4 * width * Math.cos(bankInRad);
        y1 = 0.5 * height + 0.4 * width * Math.sin(bankInRad);
        x2 = 0.5 * width - 0.3 * width * Math.cos(bankInRad);
        y2 = 0.5 * height - 0.3 * width * Math.sin(bankInRad);
        g.setColor(java.awt.Color.orange);
        g2d.drawLine((int) x1, (int) y1, (int) x2, (int) y2);
        x = 0.15 * width;
        y = height / 2.0 - 0.35 * width;
        g.setColor(java.awt.Color.green);
        g2d.drawArc((int) x, (int) y, (int) (0.7 * width), (int) (0.7 * width), 0, (int) (-1 * bank));
        x = 0.5 * width + 0.35 * width * Math.cos(bankInRad / 2);
        y = 0.5 * height + 0.35 * width * Math.sin(bankInRad / 2);
        g.setColor(java.awt.Color.black);
        g2d.drawString("\u03D5:" + (int) (bank), (int) x, (int) y);
        // draw aileronDeflection
        g.setColor(java.awt.Color.blue);
        double bankAileron = bank - aileronDeflection * 0.5;
        double bankAileronInRad = Math.toRadians(bankAileron);
        x1 = 0.5 * width + 0.2 * width * Math.cos(bankInRad);
        y1 = 0.5 * height + 0.2 * width * Math.sin(bankInRad);
        x2 = 0.5 * width + 0.3 * width * Math.cos(bankInRad);
        y2 = 0.5 * height + 0.3 * width * Math.sin(bankInRad);
        double r = 0.3 * width * Math.sin(Math.toRadians(aileronDeflection * 0.5));
        x3 = x1 + r * Math.sin(bankInRad);
        y3 = y1 - r * Math.cos(bankInRad);
        x4 = x2 + r * Math.sin(bankInRad);
        y4 = y2 - r * Math.cos(bankInRad);
        g2d.drawLine((int) x1, (int) y1, (int) x3, (int) y3);
        g2d.drawLine((int) x2, (int) y2, (int) x4, (int) y4);
        g2d.drawLine((int) x3, (int) y3, (int) x4, (int) y4);
        /* another side */
        x1 = 0.5 * width - 0.2 * width * Math.cos(bankInRad);
        y1 = 0.5 * height - 0.2 * width * Math.sin(bankInRad);
        x2 = 0.5 * width - 0.3 * width * Math.cos(bankInRad);
        y2 = 0.5 * height - 0.3 * width * Math.sin(bankInRad);
        x3 = x1 - r * Math.sin(bankInRad);
        y3 = y1 + r * Math.cos(bankInRad);
        x4 = x2 - r * Math.sin(bankInRad);
        y4 = y2 + r * Math.cos(bankInRad);
        g2d.drawLine((int) x1, (int) y1, (int) x3, (int) y3);
        g2d.drawLine((int) x2, (int) y2, (int) x4, (int) y4);
        g2d.drawLine((int) x3, (int) y3, (int) x4, (int) y4);
        /* don't need to write arc of aileron
        x = 0.5 * width - 0.25 * width;
        y = 0.5 * height - 0.25 * width;
        g.setColor(java.awt.Color.blue);
        g2d.drawArc((int) x, (int) y, (int) (0.5 * width), (int) (0.5 * width), (int) (-1 * bankAileron), (int) -1 * aileronDeflection);
         */
        double bankAileron2 = bank - aileronDeflection / 2;
        double bankAileron2InRad = Math.toRadians(bankAileron2);
        x = 0.5 * width + 0.42 * width * Math.cos(bankAileron2InRad);
        y = 0.5 * height + 0.42 * width * Math.sin(bankAileron2InRad);
        g.setColor(java.awt.Color.black);
        g2d.drawString("\u03B4A:" + aileronDeflection, (int) x, (int) y);
        // draw elevatorControl
        x = width * 0.7 - pic.getWidth() * .15 * 0.583;
        y = height * 0.96;
        g2d.drawString(l.getString("aileronControl") + "%", (int) x, (int) y);
        x = width * 0.7 - pic.getWidth() * 0.495 * 0.583;
        y = height * 0.85 - pic.getHeight() / 2 * 0.583;
        g2d.drawImage(pic, (int) x, (int) y, null);
        x1 = width * 0.7;
        y1 = height * 0.9;
        g.setColor(java.awt.Color.blue);
        double controlInRad = Math.toRadians(90 - this.aileronControl * 0.45);
        x2 = x1 + 0.6 * pic.getHeight() * Math.cos(controlInRad) * 0.583;
        y2 = y1 - 0.6 * pic.getHeight() * Math.sin(controlInRad) * 0.583;
        g2d.setStroke(new BasicStroke(3));
        g2d.drawLine((int) x1, (int) y1, (int) x2, (int) y2);
        g2d.drawOval((int) x2 - 3, (int) y2 - 3, 6, 6);
        // 
        g.setColor(java.awt.Color.black);
        controlInRad = Math.toRadians(90 - this.aileronControl * 0.225);
        x = x1 + 0.59 * pic.getHeight() * Math.cos(controlInRad) * 0.583;
        y = y1 - 0.59 * pic.getHeight() * Math.sin(controlInRad) * 0.583;
        g2d.drawString("" + aileronControl + "%", (int) x, (int) y);
        x = x1 - 0.59 * pic.getHeight() * 0.583;
        y = y1 - 0.59 * pic.getHeight() * 0.583;
        g2d.setStroke(new BasicStroke(1));
        g2d.drawArc((int) x, (int) y, (int) (1.18 * pic.getHeight() * 0.583), (int) (1.18 * pic.getHeight() * 0.583), 90, (int) (-1 * this.aileronControl * 0.45));
        // g2d.drawImage(pic2, at,  this
    }

    public void update(FSBasic fsBasic) {
        bank = fsBasic.bank();
        aileronDeflection = fsBasic.aileronDeflection();
        aileronControl = fsBasic.aileronControl();
        repaint();
    }

    public static void main(String[] args) throws InterruptedException {

        JFrame f = new JFrame("Demo");
        JPanel p = new RollPanel();
        f.add(p);

        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        f.setSize(350, 400);
        f.setVisible(true);
    }

}
